Optimization of a pulse sequence generated by ``Qiskit-pulse``
==============================================================

Here, we show a tutorial of optimizing a single X gate described by 
`DRAG pulse<https://qiskit.org/documentation/stable/0.24/stubs/qiskit.pulse.Drag.html>`
using ``qiskit_dynamics``. This tutorial includes knowledge of how to use JAX 
and the pulse schedule used in ``qiskit-pulse`` - see the user guide on 
`How-to use JAX with qiskit-dynamics` and 
`How-to use pulse schedules provided by qiskit-pulse for jax-jit`.


This tutorial consists of the following steps for optimization of :math:`X`-gate
on a qubit system model.

1. Configure dynamics to run with JAX
2. Define a transmon model with Hamiltonian and set up a simulation
3. Prepare for helper functions for the tutorial
4. Define DRAG pulse
5. Define the objective function
6. Perform JAX transformations and optimize


1. Configure dynamics to run with JAX
--------------------------------------------

First, enable JAX to operate in 64-bit mode and set cpu as a platform
in JAX. And set JAX as the default backend using ``Array`` for performing 
array operations.

The ``Array`` class provides two backends, `numpy` or `jax.numpy`. 
The default backend is `numpy`, and it needs to set `jax` as ``Array`` backend
in order to enable automatic differentiation of the Qiskit Dynamics code
in this tutorial.

.. jupyter-execute::

    import jax
    jax.config.update("jax_enable_x64", True)

    # tell JAX we are using CPU
    jax.config.update('jax_platform_name', 'cpu')

    from qiskit_dynamics.array import Array
    Array.set_default_backend('jax')

The default backend can be observed via:

.. jupyter-execute::

    Array.default_backend()


2. Define a transmon model with Hamiltonian and set up the solver
-------------------------------------------------------------------

A transmon model with Hamiltonian we will simulate is here.

.. math:: H(t) = 2 \pi \nu N + \pi \alpha N(N-I) + s(t) \times 2 \pi r (a + a^\dagger)


- :math:`N`, :math:`a`, and :math:`a^\dagger` are, respectively,
    the number, annihilation, and creation operators.
- :math:`\nu` is the qubit frequency,
- :math:`r` is the drive strength,
- :math:`s(t)` is the drive signal which we will optimize.

The following  used values is determined as typical ones.
We note that `dim` is set to 3 because DRAG pulse considers leakage to 2-state.


.. jupyter-execute::
    import numpy as np
    from qiskit.quantum_info import Operator
    from qiskit_dynamics import Solver

    dim = 3
    v = 5.
    anharm = -0.33
    r = 0.1
    dt = 0.222
    w = 5.

    a = np.diag(np.sqrt(np.arange(1, dim)), 1)
    adag = np.diag(np.sqrt(np.arange(1, dim)), -1)
    N = np.diag(np.arange(dim))


    static_hamiltonian = 2 * np.pi * v * N + np.pi * anharm * N * (N - np.eye(dim))
    drive_hamiltonian = 2 * np.pi * r * (a + adag)


    ham_solver = Solver(
        hamiltonian_operators=[drive_hamiltonian],
        static_hamiltonian=static_hamiltonian,
        rotating_frame=static_hamiltonian,
    )

3. Prepare for helper functions for the tutorial
------------------------------------------------

We want to optimize :math:`X` gate, and define the fidelity of the unitary :math:`U`
implemented by the pulse:

.. math:: f(U) = \frac{|\text{Tr}(XU)|_2|}{2}

.. jupyter-execute::

    X_op = Array(Operator(
        [[0., 1., 0.],
         [1., 0., 0.], 
         [0., 0., 1.]]))


    def fidelity(U):
        U = Array(U)
        V = Array(Operator(
        [[1., 0., 0.],
         [0., 1., 0.], 
         [0., 0., 0.]]))

        return np.abs(np.trace(X_op@(V@U@V))) / 2

At the end of this tutorial, 
we plot the shape of the pulse, and prepare a function for that.

.. jupyter-execute::
    from qiskit import pulse
    from qiskit_dynamics.pulse import InstructionToSignals
    from matplotlib import pyplot as plt

    def plot_pulse(pulse_instance: pulse.ScalableSymbolicPulse, t_max: int):
        with pulse.build() as my_pulse:
            pulse.play(pulse_instance, pulse.DriveChannel(0))
        converter = InstructionToSignals(dt, carriers={"d0": w})
        signals = converter.get_signals(my_pulse)
        fig, axs = plt.subplots(1, 2, figsize=(14, 4.5))
        for ax, title in zip(axs, ["envelope", "signal"]):
            signals[0].draw(0, t_max, 4000, title, axis=ax)
            ax.set_xlabel("Time (dt)")
            ax.set_ylabel("Amplitude")
            ax.set_title(title)


4. Define DRAG pulse
--------------------

Although qiskit provides a ``DRAG`` that generates a DRAG pulse, which is a subclass of ``ScalableSymbolicPulse``, 
this class is currently not JAX-supported.

We construct the DRAG pulse directly by ``ScalableSymbolicPulse``.

.. jupyter-execute::
    import sympy as sym

    def lifted_gaussian(
        t: sym.Symbol,
        center,
        t_zero,
        sigma,
    ) -> sym.Expr:
        t_shifted = (t - center).expand()
        t_offset = (t_zero - center).expand()

        gauss = sym.exp(-((t_shifted / sigma) ** 2) / 2)
        offset = sym.exp(-((t_offset / sigma) ** 2) / 2)

        return (gauss - offset) / (1 - offset)

    def drag(params):
        amp, beta = params
        _t, _duration, _amp, _sigma, _beta, _angle = sym.symbols(
            "t, duration, amp, sigma, beta, angle"
        )
        _center = _duration / 2
        _gauss = lifted_gaussian(_t, _center, _duration + 1, _sigma)
        _deriv = -(_t - _center) / (_sigma**2) * _gauss

        envelope_expr = _amp * sym.exp(sym.I * _angle) * (_gauss + sym.I * _beta * _deriv)
        
        return pulse.ScalableSymbolicPulse(
                pulse_type="Drag",
                duration=160,
                amp=amp,
                angle=0,
                parameters={"sigma": 40, "beta": beta},
                envelope=envelope_expr,
                constraints=_sigma > 0,
                valid_amp_conditions=sym.And(sym.Abs(_amp) <= 1.0, sym.Abs(_beta) < _sigma),
            )

5. Define the objective function
--------------------------------

The role of the function we want to optimize is:

- Setting params we want to optimze. In this time, we optimize amplifier and beta.
- Constructing qiskit-pulse using parametrized drag pulse and converting to signal.
- Simulating the equation over the length of the pulse sequence.
- Computing and return the infidelity (we minimize :math:`1-f(U)`).

.. jupyter-execute::
    def objective(params):

        instance = drag(params)

        # build a pulse schedule
        with pulse.build() as Xp:
            pulse.play(instance, pulse.DriveChannel(0))

        # convert from a pulse schedule to a list of signals
        converter = InstructionToSignals(dt, carriers={"d0": w})

        # get signals for the converter
        signal = converter.get_signals(Xp)

        result = ham_solver.solve(
            y0=np.eye(3, dtype=complex),
            t_span=[0, instance.duration * dt],
            signals=[signal],
            method='jax_odeint',
            atol=1e-8,
            rtol=1e-8
        )

        return 1. - fidelity(Array(result[0].y[-1])).data

6. Perform JAX transformations and optimize
-------------------------------------------

Finally, we gradient optimize the objective:

-  Use ``jax.value_and_grad`` to transform the objective into a function
   that computes both the objective and the gradient.
-  Use ``jax.jit`` to just-in-time compile the function into optimized
   `XLA <https://www.tensorflow.org/xla>`__ code. For the initial cost of
   performing the compilation, this speeds up each call of the function,
   speeding up the optimization.
-  Call ``scipy.optimize.minimize`` with the above, with
   ``method='L-BFGS-B'`` and ``jac=True`` to indicate that the passed
   objective also computes the gradient.

We set amplifier and beta as :math:`initial_params = [0.2, 10,]`.
Before the optimization, the shape of the signal is here.

.. jupyter-execute::
    plot_pulse(drag(initial_params), 40)

.. jupyter-execute::
    from jax import jit, value_and_grad
    from scipy.optimize import minimize

    jit_grad_obj = jit(value_and_grad(objective))

    initial_params = [0.2, 10,]


    opt_results = minimize(fun=jit_grad_obj, x0=initial_params, jac=True, method='L-BFGS-B',
    bounds=((0.,1.), (None, None)))

    print(opt_results.message)
    print(f"Optimized Amp is {opt_results.x[0]} and beta is {opt_results.x[1]}")
    print('Number of function evaluations: ' + str(opt_results.nfev))
    print('Function value: ' + str(opt_results.fun))

We can draw the optimized signal, whose parameter is retrieved by :math:`opt_results.x`.

.. jupyter-execute::
    plot_pulse(drag(opt_results.x), 40)
