.. _how-to use pulse schedules for jax-jit:

How-to use pulse schedules provided by ``qiskit-pulse`` for jax-jit
===================================================================

``Qiskit-pulse`` provides pulse schedules including instruction sequences.
Pulses are executed under `Play` instruction which is one of some instructions.
(see the detailed  API information about 
`Qiskit pulse API Reference <https://qiskit.org/documentation/apidoc/pulse.html>`__.)
Several pulse instances are available to users, and now that
JAX support for ``ScalableSymbolicPulse`` class has been completed from ``qiskit-terra`` 0.23.0.
We describe how to use it.

.. warning::
    This is an advanced topic --- Some extend of knowledge about ``Qiskit-pulse`` is required.
    See `Qiskit pulse API Reference <https://qiskit.org/documentation/apidoc/pulse.html>`__ for the detailed  API information.
    Also, see `Qiskit tutorial <https://qiskit.org/documentation/tutorials/circuits_advanced/06_building_pulse_schedules.html>`__ 
    for a tutorial about a pulse scheduler.

.. note::
    At present, only the ``ScalableSymbolicPulse`` class is supported by JAX.
    We cannot use any subclasses such as ``Gaussian`` and ``GaussianSquare``
    for JAX.

This guide addresses the following topics.
See the :ref:`userguide on using JAX <how-to use jax>` for a more detailed
explanation of how to work with JAX in Qiskit Dynamics.

1. Configure to use JAX
2. Import libraries and Set up some functions for assistance
3. How to use a variety of ``ScalableSymbolicPulse``
4. How to execute jit compilation using ``ScalableSymbolicPulse``


1. Configure to use JAX
-----------------------

This userguide uses JAX for jax-jit compile.

.. jupyter-execute::

    # configure jax to use 64 bit mode
    import jax
    jax.config.update("jax_enable_x64", True)

    # tell JAX we are using CPU
    jax.config.update('jax_platform_name', 'cpu')

    # import Array and set default backend
    from qiskit_dynamics.array import Array
    Array.set_default_backend('jax')


2. Import libraries and Set up some functions for assistance
------------------------------------------------------------

.. jupyter-execute::

    from matplotlib import pyplot as plt
    from qiskit import pulse
    from qiskit_dynamics.pulse import InstructionToSignals
    import sympy as sym

    dt = 0.222
    w = 5.

    # Plot the envelopes and the signals from the conversion class InstructionToSignals
    def plot_pulse(pulse_instance: pulse.ScalableSymbolicPulse, t_max: int):
        with pulse.build() as my_pulse:
            pulse.play(pulse_instance, pulse.DriveChannel(0))
        converter = InstructionToSignals(dt, carriers={"d0": w})
        signals = converter.get_signals(my_pulse)
        fig, axs = plt.subplots(1, 2, figsize=(14, 4.5))
        for ax, title in zip(axs, ["envelope", "signal"]):
            signals[0].draw(0, t_max, 4000, title, axis=ax)
            ax.set_xlabel("Time (dt)")
            ax.set_ylabel("Amplitude")
            ax.set_title(title)
    
    # Helper function that returns a lifted Gaussian symbolic equation.
    def lifted_gaussian(
        t: sym.Symbol,
        center,
        t_zero,
        sigma,
    ) -> sym.Expr:
        t_shifted = (t - center).expand()
        t_offset = (t_zero - center).expand()

        gauss = sym.exp(-((t_shifted / sigma) ** 2) / 2)
        offset = sym.exp(-((t_offset / sigma) ** 2) / 2)

        return (gauss - offset) / (1 - offset)


3. How to use a variety of ``ScalableSymbolicPulse``
----------------------------------------------------

Here are some example pulses generated using ``ScalableSymbolicPulse``.

A simple constant pulse is generated by the following codes.
It notes that each values of amplifier, angle, and duration are typical ones.

.. jupyter-execute::

    _t, _amp, _duration, _angle = sym.symbols("t, amp, duration, angle")

    envelope_expr = (
        _amp
        * sym.exp(sym.I * _angle)
        * sym.Piecewise((1, sym.And(_t >= 0, _t <= _duration)), (0, True))
    )

    constant_pulse = pulse.ScalableSymbolicPulse(
            pulse_type="Constant",
            duration=40,
            amp=1,
            angle=0,
            envelope=envelope_expr,
            valid_amp_conditions=sym.Abs(_amp) <= 1.0,
        )

    plot_pulse(constant_pulse,10)


A Gaussian pulse is generated by the following codes.
It notes that values of amplifier, angle, sigma and duration are typical ones.

.. jupyter-execute::

    _t, _duration, _amp, _sigma, _angle = sym.symbols("t, duration, amp, sigma, angle")
    _center = _duration / 2

    envelope_expr = (
        _amp * sym.exp(sym.I * _angle) * lifted_gaussian(_t, _center, _duration + 1, _sigma)
    )

    gaussian_pulse = pulse.ScalableSymbolicPulse(
            pulse_type="Gaussian",
            duration=160,
            amp=0.3,
            angle=0,
            parameters={"sigma": 40},
            envelope=envelope_expr,
            constraints=_sigma > 0,
            valid_amp_conditions=sym.Abs(_amp) <= 1.0,
        )

    plot_pulse(gaussian_pulse,40)

A GaussianSquare pulse is a square pulse with a Gaussian shaped risefall 
on both sides.
It notes that values of amplifier, angle, sigma, width and duration are typical ones.

.. jupyter-execute::

    _t, _duration, _amp, _sigma, _width, _angle = sym.symbols(
        "t, duration, amp, sigma, width, angle"
    )
    _center = _duration / 2

    _sq_t0 = _center - _width / 2
    _sq_t1 = _center + _width / 2

    _gaussian_ledge = lifted_gaussian(_t, _sq_t0, -1, _sigma)
    _gaussian_redge = lifted_gaussian(_t, _sq_t1, _duration + 1, _sigma)

    envelope_expr = (
        _amp
        * sym.exp(sym.I * _angle)
        * sym.Piecewise(
            (_gaussian_ledge, _t <= _sq_t0), (_gaussian_redge, _t >= _sq_t1), (1, True)
        )
    )

    gaussian_square_pulse = pulse.ScalableSymbolicPulse(
            pulse_type="GaussianSquare",
            duration=200,
            amp=0.3,
            angle=0,
            parameters={"sigma": 4, "width": 150},
            envelope=envelope_expr,
            constraints=sym.And(_sigma > 0, _width >= 0, _duration >= _width),
            valid_amp_conditions=sym.Abs(_amp) <= 1.0,
        )

    plot_pulse(gaussian_square_pulse,50)


The Derivative Removal by Adiabatic Gate (DRAG) pulse is a standard Gaussian pulse propagating
with an additional Gaussian derivative part, which is utilized for a X gate.
It notes that values of amplifier, angle, sigma, beta and duration are typical ones.

.. jupyter-execute::

    _t, _duration, _amp, _sigma, _beta, _angle = sym.symbols(
                "t, duration, amp, sigma, beta, angle"
            )
    _center = _duration / 2
    _gauss = lifted_gaussian(_t, _center, _duration + 1, _sigma)
    _deriv = -(_t - _center) / (_sigma**2) * _gauss
    envelope_expr = _amp * sym.exp(sym.I * _angle) * (_gauss + sym.I * _beta * _deriv)
    drag_pulse = pulse.ScalableSymbolicPulse(
            pulse_type="Drag",
            duration=160,
            amp=0.5,
            angle=0,
            parameters={"sigma": 40, "beta": 2},
            envelope=envelope_expr,
            constraints=_sigma > 0,
            valid_amp_conditions=sym.And(sym.Abs(_amp) <= 1.0, sym.Abs(_beta) < _sigma),
        )
    plot_pulse(drag_pulse,40)


4. How to execute jit compilation using ``ScalableSymbolicPulse``
-----------------------------------------------------------------

Using the ``wrap`` function enable to execute jit compilation even if a type of a return value is ``Array``.
see :ref:`How-to use JAX with qiskit-dynamics <how-to use jax>` for the basis of using JAX with ``qiskit-dynamics``.

.. jupyter-execute::

    from qiskit_dynamics.array import wrap

    jit = wrap(jax.jit, decorator=True)



Using a Gaussian pulse as an example, jit compilation is executed as follows.

.. jupyter-execute::

    # use Amplifier as a variable
    def jit_func(amp):
        _t, _duration, _amp, _sigma, _angle = sym.symbols("t, duration, amp, sigma, angle")
        _center = _duration / 2
        envelope_expr = (
            _amp * sym.exp(sym.I * _angle) * lifted_gaussian(_t, _center, _duration + 1, _sigma)
        )
        gaussian_pulse = pulse.ScalableSymbolicPulse(
                pulse_type="Gaussian",
                duration=160,
                amp=amp,
                angle=0,
                parameters={"sigma": 40},
                envelope=envelope_expr,
                constraints=_sigma > 0,
                valid_amp_conditions=sym.Abs(_amp) <= 1.0,
            )
        # build a pulse schedule
        with pulse.build() as schedule:
            pulse.play(gaussian_pulse, pulse.DriveChannel(0))

        # convert from a pulse schedule to a list of signals
        converter = InstructionToSignals(dt, carriers={"d0": w})
        
        return converter.get_signals(schedule)[0].samples

    jit(jit_func)(0.4)


If you are interested in experience the effects of jax-jit compilation, 
here is a tutorial.