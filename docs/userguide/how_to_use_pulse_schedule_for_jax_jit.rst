.. _how-to use pulse schedules for jax-jit:

How-to use pulse schedules provided by ``qiskit-pulse`` for jax-jit
===================================================================

``Qiskit-pulse`` provides pulse schedules including instruction sequences.
Pulses are executed under `Play` instruction which is one of some instructions.
(see the detailed  API information about 
`Qiskit pulse API Reference <https://qiskit.org/documentation/apidoc/pulse.html>`__.)
Several pulse instances are available to users, and now that
JAX support for ``ScalableSymbolicPulse`` class has been completed from ``qiskit-terra`` 0.23.0.
We describe how to use it.

.. note::
    At present, only the ``ScalableSymbolicPulse`` class is supported by JAX, as the validation
    present in other pulse types, such as ``Gaussian``, is not JAX-compatible.

This guide addresses the following topics.
See the :ref:`userguide on using JAX <how-to use jax>` for a more detailed
explanation of how to work with JAX in Qiskit Dynamics.

1. Configure to use JAX
2. How to generate a variety of pulses by ``ScalableSymbolicPulse``
3. How to execute jit compilation using ``ScalableSymbolicPulse``


1. Configure to use JAX
-----------------------

This userguide uses JAX for jax-jit compile.

.. jupyter-execute::

    # configure jax to use 64 bit mode
    import jax
    jax.config.update("jax_enable_x64", True)

    # tell JAX we are using CPU
    jax.config.update('jax_platform_name', 'cpu')

    # import Array and set default backend
    from qiskit_dynamics.array import Array
    Array.set_default_backend('jax')


2. How to generate a gaussion pulse by ``ScalableSymbolicPulse``
-------------------------------------------------------------------

.. jupyter-execute::

    from qiskit import pulse
    from qiskit_dynamics.pulse import InstructionToSignals
    import sympy as sym

    dt = 0.222
    w = 5.

    # Helper function that returns a lifted Gaussian symbolic equation.
    def lifted_gaussian(
        t: sym.Symbol,
        center,
        t_zero,
        sigma,
    ) -> sym.Expr:
        t_shifted = (t - center).expand()
        t_offset = (t_zero - center).expand()

        gauss = sym.exp(-((t_shifted / sigma) ** 2) / 2)
        offset = sym.exp(-((t_offset / sigma) ** 2) / 2)

        return (gauss - offset) / (1 - offset)


Here is an example of a gaussian pulse generated using ``ScalableSymbolicPulse``.


A Gaussian pulse is generated by the following codes.
It notes that values of amplifier, angle, sigma and duration are typical ones.

.. jupyter-execute::

    _t, _duration, _amp, _sigma, _angle = sym.symbols("t, duration, amp, sigma, angle")
    _center = _duration / 2

    envelope_expr = (
        _amp * sym.exp(sym.I * _angle) * lifted_gaussian(_t, _center, _duration + 1, _sigma)
    )

    gaussian_pulse = pulse.ScalableSymbolicPulse(
            pulse_type="Gaussian",
            duration=160,
            amp=0.3,
            angle=0,
            parameters={"sigma": 40},
            envelope=envelope_expr,
            constraints=_sigma > 0,
            valid_amp_conditions=sym.Abs(_amp) <= 1.0,
        )

    gaussian_pulse.draw()


4. JAX transforming Pulse to Signal conversion involving ``ScalableSymbolicPulse``
------------------------------------------------------------------------------------

Using a Gaussian pulse as an example, we show that code involving ``ScalableSymbolicPulse``
and the pulse to signal converter can be JAX-compiled (or more generally, JAX-transformed).

.. jupyter-execute::

    # use Amplifier as a variable
    def jit_func(amp):
        _t, _duration, _amp, _sigma, _angle = sym.symbols("t, duration, amp, sigma, angle")
        _center = _duration / 2

        envelope_expr = (
            _amp * sym.exp(sym.I * _angle) * lifted_gaussian(_t, _center, _duration + 1, _sigma)
        )

        gaussian_pulse = pulse.ScalableSymbolicPulse(
                pulse_type="Gaussian",
                duration=160,
                amp=amp,
                angle=0,
                parameters={"sigma": 40},
                envelope=envelope_expr,
                constraints=_sigma > 0,
                valid_amp_conditions=sym.Abs(_amp) <= 1.0,
            )

        # build a pulse schedule
        with pulse.build() as schedule:
            pulse.play(gaussian_pulse, pulse.DriveChannel(0))

        # convert from a pulse schedule to a list of signals
        converter = InstructionToSignals(dt, carriers={"d0": w})
        
        return converter.get_signals(schedule)[0].samples.data

    jax.jit(jit_func)(0.4)
